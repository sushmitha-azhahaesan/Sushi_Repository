# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
'''
Lets consider a brief example;
         --1
        /    \
    --2      --3
    /   \     /  \
--4    --5 --6  --7

There are about 2 approaches to solve this 
1. recursion
2. iteration

Recursion:
   Every time in preorder traversal all nodes gets visited only once
   root, left , right
   the order will be [1,2,4,5,3,6,7]
   For recursion we have to identify the base case(when will the recursion stop/end point for a recursion) and the recursive case
   Base case: if root is None return the empty list
   recursive case: traverse root + call function with left +call function with right
   [1],2()
   [2],4()
   [4],[],[]
   
   right of 4 -->5
   5()-->[],[]
   [5]
   [4,5]-->[2,4,5]-->[1,2,4,5]
   right of 1 -->3
   [3],6()
   [6],[],[]
   [7],[] [] ------>[6,7] --->[3,6,7]-->[1,2,4,5,3,6,7]
'''
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        #base case
        if root is None:
            return []
        #recursive case [] for root.val since we r returning list of numbers
        else:
            return [root.val] + self.preorderTraversal(root.left) +self.preorderTraversal(root.right)
        
